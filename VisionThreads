    public void theThreadThatCould(){
    	new Thread(() -> {
    		UsbCamera camera = CameraServer.getInstance().startAutomaticCapture();
    		
    		CvSink cvSink = CameraServer.getInstance().getVideo();
    		CvSource outputStream = CameraServer.getInstance().putVideo("theThreadThatCould", 160, 120);  		

    		Mat source = new Mat();
    		Mat output = new Mat();
    		
    		while(!Thread.interrupted()){
    			cvSink.grabFrame(source);

//    			Imgproc.cvtColor(source, output, Imgproc.COLOR_BGR2GRAY);
    			outputStream.putFrame(source);
    		}
    	}).start();
    }
    
    //DONT EVER EVER EVER EVER EVER TOUCH
    public void simpleThread() {
    	new Thread(() -> {
    		UsbCamera camera = CameraServer.getInstance().startAutomaticCapture();
    		
    		CvSink cvSink = CameraServer.getInstance().getVideo();
    		CvSource outputStream = CameraServer.getInstance().putVideo("BestThread", 160, 120);  		
    		
    		Mat source = new Mat();
    		Mat output = new Mat();
    		
    		while(!Thread.interrupted()){
    			cvSink.grabFrame(source);
    			int blue = 1;
    			int blueMod = 1;
    			
    			int green = 1;
    			int greenMod = 1;
    			
    			int red = 1;
    			int redMod = 1;
    	
    			Imgproc.cvtColor(source, output, Imgproc.COLOR_BGR2GRAY);
    			outputStream.putFrame(output);
    		}
    	}).start();
    }
    
    public void newThread() {
    	new Thread(() -> {
    		UsbCamera camera = CameraServer.getInstance().startAutomaticCapture();
    		camera.setResolution(IMG_WIDTH, IMG_HEIGHT);
    		camera.setBrightness(0);
    		camera.setExposureManual(0);
    		
    		CvSink cvSink = CameraServer.getInstance().getVideo();
    		CvSource outputStream = CameraServer.getInstance().putVideo("New", IMG_WIDTH, IMG_HEIGHT);
//    		CvSink plsWork = CameraServer.getInstance().getVideo();
//    		CvSource pleaaaase = CameraServer.getInstance().putVideo("Working!!!", 160, 120);
	    	
    		GripPipeline grip = new GripPipeline();
    		
	    	Mat source = new Mat();
	    	Mat output = new Mat();
	    	long time = 0;
	    	try {
	    		Thread.sleep(1000);
	    	}catch(Exception e){}
    		//contour vars
    		ArrayList<MatOfPoint> findContoursOutput = new ArrayList<MatOfPoint>();
    		ArrayList<MatOfPoint> filterContoursContours = findContoursOutput;
    		ArrayList<MatOfPoint> filterContoursOutput = new ArrayList<MatOfPoint>();
    		double filterContoursMinArea = 20.0;
    		double filterContoursMinPerimeter = 20.0;
    		double filterContoursMinWidth = 0.0;
    		double filterContoursMaxWidth = 1000;
    		double filterContoursMinHeight = 0;
    		double filterContoursMaxHeight = 1000;
    		double[] filterContoursSolidity = {0, 100};
    		double filterContoursMaxVertices = 1000000;
    		double filterContoursMinVertices = 0;
    		double filterContoursMinRatio = 0;
    		double filterContoursMaxRatio = 1000;
    		double[] orangeHue = {0.0, 40.0};
    		double[] orangeSat = {200.0, 255.0};
    		double[] orangeValue = {40.0, 100.0};
    		double[] greenHue = {40.0, 100.0};
    		double[] greenSat = {200.0, 255.0};
    		double[] geenValue = {200.0, 255.0};
    		
			double[] hue = orangeHue;
			double[] sat = orangeSat;
			double[] val = orangeValue;
	    	
    		while(!Thread.interrupted()) {
    			cvSink.grabFrame(source);
    			int blue = 1;
    			int blueMod = 1;
    			
    			int green = 1;
    			int greenMod = 1;
    			
    			int red = 1;
    			int redMod = 1;
    			
        		grip.hsvThreshold(source, hue, sat, val, output);
        		grip.desaturate(output, output);
        		grip.findContours(output, false, findContoursOutput);
        		grip.filterContours(filterContoursContours, filterContoursMinArea, filterContoursMinPerimeter, filterContoursMinWidth, 
        						filterContoursMaxWidth, filterContoursMinHeight, filterContoursMaxHeight, filterContoursSolidity, 
        						filterContoursMaxVertices, filterContoursMinVertices, filterContoursMinRatio, filterContoursMaxRatio, filterContoursOutput);

        		try {
	        		r = Imgproc.boundingRect(filterContoursOutput.get(0));
	        		r2 = Imgproc.boundingRect(filterContoursOutput.get(1));
//	        		for(int i=1; i<filterContoursOutput.size(); i++) {
//	            		r2 = Imgproc.boundingRect(filterContoursOutput.get(i));
//	        			int middle = (r2.width/2) + r2.x;
//	            		if(middle < r.x && middle > r.x + r.width)
//	            			break;
//	        		}
        		}catch(Exception e) {}
        			
        			//change colors 0_o
        		if(blue >= 255 || blue <= 0){
        			blueMod *= -1;
        		}
        		blue += 8*blueMod;
        		
        		if(green >= 255 || green <= 0){
        			greenMod *= -1;
        		}
        		green += 12*greenMod;
        		
        		if(red >= 255 || red <= 0){
        			redMod *= -1;
        		}
        		red += 16*redMod;
        		size = 0;
        		
        		if(filterContoursOutput.size() != 0) {
        			synchronized(imgLock) {
        				size = filterContoursOutput.size();
        				centerX = r.x+(r.width/2);
        				height = r.height;
        			}
        			Imgproc.rectangle(source, new Point(r.x, r.y), new Point(r.x+r.width, r.y+r.height), new Scalar(255, 0, 0));
        			if(filterContoursOutput.size() > 1) {
        				Imgproc.rectangle(source, new Point(r2.x, r2.y), new Point(r2.x+r2.width, r2.y+r2.height), new Scalar(0, 0, 255));
        			}
        		}
	        	Imgproc.putText(source, "v1.3", new Point(output.rows()/8,output.cols()/8), Core.FONT_ITALIC, 0.5, new Scalar(255,255,255), 1);
	        	time = System.currentTimeMillis() - time;
	        	double newTime = 1000/((double)time);
	        	Imgproc.putText(source, "" + (int)newTime + " fps", new Point(output.rows()/8,output.cols()/4), Core.FONT_ITALIC, 0.4, new Scalar(255,255,255), 1);
	            	
    			outputStream.putFrame(source);
    		}
    	}).start();
    }
    
    public void basicThread() {
    	new Thread(() -> {
	    	UsbCamera camera = CameraServer.getInstance().startAutomaticCapture();
	    	camera.setResolution(IMG_WIDTH, IMG_HEIGHT);
	    	camera.setBrightness(0);
	    	camera.setExposureManual(0);
	    	
	    	CvSink cvSink = CameraServer.getInstance().getVideo();
	    	CvSource outputStream = CameraServer.getInstance().putVideo("v1.1", IMG_WIDTH, IMG_HEIGHT);
	    	GripPipeline grip  = new GripPipeline();
	    	
	    	Mat source = new Mat();
	    	Mat output = new Mat();
	    	long time = 0;
	    	try {
	    		Thread.sleep(1000);
	    	}catch(Exception e){}
    		//contour vars
    		ArrayList<MatOfPoint> findContoursOutput = new ArrayList<MatOfPoint>();
    		ArrayList<MatOfPoint> filterContoursContours = findContoursOutput;
    		ArrayList<MatOfPoint> filterContoursOutput = new ArrayList<MatOfPoint>();
    		double filterContoursMinArea = 20.0;
    		double filterContoursMinPerimeter = 20.0;
    		double filterContoursMinWidth = 0.0;
    		double filterContoursMaxWidth = 1000;
    		double filterContoursMinHeight = 0;
    		double filterContoursMaxHeight = 1000;
    		double[] filterContoursSolidity = {0, 100};
    		double filterContoursMaxVertices = 1000000;
    		double filterContoursMinVertices = 0;
    		double filterContoursMinRatio = 0;
    		double filterContoursMaxRatio = 1000;
    		double[] orangeHue = {0.0, 40.0};
    		double[] orangeSat = {200.0, 255.0};
    		double[] orangeValue = {40.0, 100.0};
    		double[] greenHue = {40.0, 100.0};
    		double[] greenSat = {200.0, 255.0};
    		double[] geenValue = {200.0, 255.0};
    		
			double[] hue = orangeHue;
			double[] sat = orangeSat;
			double[] val = orangeValue;
	    	
	    	while(!Thread.interrupted()) {
	    		time = System.currentTimeMillis();
	    		cvSink.grabFrame(source);
        		
    			//change colors 0_o
    			int blue = 1;
    			int blueMod = 1;
    			
    			int green = 1;
    			int greenMod = 1;
    			
    			int red = 1;
    			int redMod = 1;
    			
        		grip.hsvThreshold(source, hue, sat, val, output);
        		grip.desaturate(output, output);
        		grip.findContours(output, false, findContoursOutput);
        		grip.filterContours(filterContoursContours, filterContoursMinArea, filterContoursMinPerimeter, filterContoursMinWidth, 
        						filterContoursMaxWidth, filterContoursMinHeight, filterContoursMaxHeight, filterContoursSolidity, 
        						filterContoursMaxVertices, filterContoursMinVertices, filterContoursMinRatio, filterContoursMaxRatio, filterContoursOutput);
                    
        		try {
	        		r = Imgproc.boundingRect(filterContoursOutput.get(0));
	        		r2 = Imgproc.boundingRect(filterContoursOutput.get(1));
//	        		for(int i=1; i<filterContoursOutput.size(); i++) {
//	            		r2 = Imgproc.boundingRect(filterContoursOutput.get(i));
//	        			int middle = (r2.width/2) + r2.x;
//	            		if(middle < r.x && middle > r.x + r.width)
//	            			break;
//	        		}
        		}catch(Exception e) {}
        			
        			//change colors 0_o
        		if(blue >= 255 || blue <= 0){
        			blueMod *= -1;
        		}
        		blue += 8*blueMod;
        		
        		if(green >= 255 || green <= 0){
        			greenMod *= -1;
        		}
        		green += 12*greenMod;
        		
        		if(red >= 255 || red <= 0){
        			redMod *= -1;
        		}
        		red += 16*redMod;
        		size = 0;
        		
        		if(filterContoursOutput.size() != 0) {
        			synchronized(imgLock) {
        				size = filterContoursOutput.size();
        				centerX = r.x+(r.width/2);
        				height = r.height;
        			}
        			Imgproc.rectangle(source, new Point(r.x, r.y), new Point(r.x+r.width, r.y+r.height), new Scalar(255, 0, 0));
        			if(filterContoursOutput.size() > 1) {
        				Imgproc.rectangle(source, new Point(r2.x, r2.y), new Point(r2.x+r2.width, r2.y+r2.height), new Scalar(0, 0, 255));
        			}
        		}
        	Imgproc.putText(source, "v1.3", new Point(output.rows()/8,output.cols()/8), Core.FONT_ITALIC, 0.5, new Scalar(255,255,255), 1);
        	time = System.currentTimeMillis() - time;
        	double newTime = 1000/((double)time);
        	Imgproc.putText(source, "" + (int)newTime + " fps", new Point(output.rows()/8,output.cols()/4), Core.FONT_ITALIC, 0.4, new Scalar(255,255,255), 1);
            	
	    	outputStream.putFrame(source);
	    	}
    	}).start();
    }
//    
//    public void sorenIdea() {
//    	GripPipeline grip = new GripPipeline();
//  
//    	new Thread(() -> {
//            UsbCamera camera = CameraServer.getInstance().startAutomaticCapture();
//            camera.setResolution(IMG_WIDTH, IMG_HEIGHT);
//            camera.setBrightness(0);
//            camera.setExposureManual(0);
//            //camera.setFPS(30);
//
//            System.out.println(" ERROR AT GETVIDEO");
//            CvSink cvSink = CameraServer.getInstance().getVideo();
//            System.out.println(" ERROR AT PUTVIDEO");
//            CvSource outputStream = CameraServer.getInstance().putVideo("v1.4", IMG_WIDTH, IMG_HEIGHT);
//            Mat source = new Mat();
//            Mat output = new Mat();
//            long time = 0;
//            
//            System.out.println("start while loop");
//            
//            while(!Thread.interrupted()) {
//            	time = System.currentTimeMillis();
//                cvSink.grabFrame(source);
//                //Imgproc.cvtColor(source, output, Imgproc.COLOR_BGR2GRAY);
//                //contour vars
//        		ArrayList<MatOfPoint> findContoursOutput = new ArrayList<MatOfPoint>();
//        		ArrayList<MatOfPoint> filterContoursContours = findContoursOutput;
//        		ArrayList<MatOfPoint> filterContoursOutput = new ArrayList<MatOfPoint>();
//        		double filterContoursMinArea = 20.0;
//        		double filterContoursMinPerimeter = 20.0;
//        		double filterContoursMinWidth = 0.0;
//        		double filterContoursMaxWidth = 1000;
//        		double filterContoursMinHeight = 0;
//        		double filterContoursMaxHeight = 1000;
//        		double[] filterContoursSolidity = {0, 100};
//        		double filterContoursMaxVertices = 1000000;
//        		double filterContoursMinVertices = 0;
//        		double filterContoursMinRatio = 0;
//        		double filterContoursMaxRatio = 1000;
//        		
//    			double[] hue = {30.0, 100.0};
//    			double[] sat = {200.0, 255.0};
//    			double[] val = {60.0, 110.0};
//        		
//    			//change colors 0_o
//    			int blue = 1;
//    			int blueMod = 1;
//    			
//    			int green = 1;
//    			int greenMod = 1;
//    			
//    			int red = 1;
//    			int redMod = 1;
//    			
//        			grip.hsvThreshold(source, hue, sat, val, output);
//        			grip.desaturate(output, output);
//        			grip.findContours(output, false, findContoursOutput);
//        			grip.filterContours(filterContoursContours, filterContoursMinArea, filterContoursMinPerimeter, filterContoursMinWidth, 
//        						filterContoursMaxWidth, filterContoursMinHeight, filterContoursMaxHeight, filterContoursSolidity, 
//        						filterContoursMaxVertices, filterContoursMinVertices, filterContoursMinRatio, filterContoursMaxRatio, filterContoursOutput);
//                    
//        			try{
//        			r = Imgproc.boundingRect(filterContoursOutput.get(0));
//        			r2 = Imgproc.boundingRect(filterContoursOutput.get(1));
//        			
//        			}catch(Exception e) {}
//        			
//        			//change colors 0_o
//        			if(blue >= 255 || blue <= 0){
//        				blueMod *= -1;
//        			}
//        			blue += 8*blueMod;
//        			
//        			if(green >= 255 || green <= 0){
//        				greenMod *= -1;
//        			}
//        			green += 12*greenMod;
//        			
//        			if(red >= 255 || red <= 0){
//        				redMod *= -1;
//        			}
//        			red += 16*redMod;
//        			size = 0;
//        			
//        			if(filterContoursOutput.size() != 0) {
//        				synchronized(imgLock) {
//        					size = filterContoursOutput.size();
//        					centerX = r.x+(r.width/2) + r2.x+(r2.width/2);
//        					centerX /= 2;
//        					height = r.y;
//        				}
//        				Imgproc.rectangle(source, new Point(r.x, r.y), new Point(r.x+r.width, r.y+r.height), new Scalar(0, 0, 255));
//        				Imgproc.rectangle(source, new Point(r2.x, r2.y), new Point(r2.x+r2.width, r2.y+r2.height), new Scalar(0, 0, 255));
//        			}
//        		Imgproc.putText(source, "v1.3", new Point(output.rows()/8,output.cols()/8), Core.FONT_ITALIC, 0.5, new Scalar(255,255,255), 1);
//        		time = System.currentTimeMillis() - time;
//        		double newTime = 1000/((double)time);
//        		Imgproc.putText(source, "" + (int)newTime + " fps", new Point(output.rows()/8,output.cols()/4), Core.FONT_ITALIC, 0.4, new Scalar(255,255,255), 1);
//            		
//                outputStream.putFrame(source);
//            }
//           
//    	}).start();
//    }
    
    
    public void actuallyTheBestWorkingIdea() {
    	GripPipeline grip = new GripPipeline();
    	new Thread(() -> {
    		CameraServer camera = CameraServer.getInstance();
    		UsbCamera cam = camera.startAutomaticCapture();
    		cam.setFPS(5);
    		CvSink cvSink = camera.getVideo();
    		int identity = 1;
    		CvSource outputStream = camera.putVideo(identity+"", 160, 120);
    		
    		Mat source = new Mat();
    		Mat output = new Mat();
    		
    		//contour vars
    		ArrayList<MatOfPoint> findContoursOutput = new ArrayList<MatOfPoint>();
    		ArrayList<MatOfPoint> filterContoursContours = findContoursOutput;
    		ArrayList<MatOfPoint> filterContoursOutput = new ArrayList<MatOfPoint>();
    		double filterContoursMinArea = 100.0;
    		double filterContoursMinPerimeter = 200.0;
    		double filterContoursMinWidth = 0.0;
    		double filterContoursMaxWidth = 1000;
    		double filterContoursMinHeight = 0;
    		double filterContoursMaxHeight = 1000;
    		double[] filterContoursSolidity = {0, 100};
    		double filterContoursMaxVertices = 1000000;
    		double filterContoursMinVertices = 0;
    		double filterContoursMinRatio = 0;
    		double filterContoursMaxRatio = 1000;
    		
			double[] hue = {40.0, 100.0};
			double[] sat = {0.0, 255.0};
			double[] val = {200.0, 255.0};
    		
			//change colors 0_o
			int brown = 1;
			int brownMod = 1;
			
			int green = 1;
			int greenMod = 1;
			
			int red = 1;
			int redMod = 1;
			long time = 0;
//			
    		while(!Thread.interrupted()){
    			time = System.currentTimeMillis();
    			cvSink.grabFrame(source);
//    			grip.hsvThreshold(source, hue, sat, val, output);
//    			grip.desaturate(output, output);
//    			grip.findContours(output, false, findContoursOutput);
//    			grip.filterContours(filterContoursContours, filterContoursMinArea, filterContoursMinPerimeter, filterContoursMinWidth, 
//    						filterContoursMaxWidth, filterContoursMinHeight, filterContoursMaxHeight, filterContoursSolidity, 
//    						filterContoursMaxVertices, filterContoursMinVertices, filterContoursMinRatio, filterContoursMaxRatio, filterContoursOutput);
//                
//    			try{
//    			r = Imgproc.boundingRect(filterContoursOutput.get(0));
//    			
//    			}catch(Exception e) {}
//    			
//    			//change colors 0_o
//    			if(brown >= 255 || brown <= 0){
//    				brownMod *= -1;
//    			}
//    			brown += 8*brownMod;
//    			
//    			if(green >= 255 || green <= 0){
//    				greenMod *= -1;
//    			}
//    			green += 12*greenMod;
//    			
//    			if(red >= 255 || red <= 0){
//    				redMod *= -1;
//    			}
//    			red += 16*redMod;
//    			
//    			if(filterContoursOutput.size() != 0) {
////    				turn = (r.x+(r.width/2))-(IMG_WIDTH/2);
////    				turn /= IMG_WIDTH;
////    				if(turn > 0.2)
////    					turn = 0.2;
////    				if(turn < -0.2)
////    					turn = -0.2;
//    				Imgproc.rectangle(source, new Point(r.x, r.y), new Point(r.x+r.width, r.y+r.height), new Scalar(brown, green, red));
//    			}
//                synchronized (imgLock) {
//                	
//                    centerX = r.x + (r.width / 2);
//                    size = findContoursOutput.size();
//                }
    			//Imgproc.cvtColor(source, output, Imgproc.COLOR_BGR2GRAY);
    			time = System.currentTimeMillis() - time;
    			System.out.println(time);
    			outputStream.putFrame(source);
    		}
    	}).start();
    }